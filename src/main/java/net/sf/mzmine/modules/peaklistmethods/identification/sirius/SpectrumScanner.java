/*
 * Copyright 2006-2018 The MZmine 2 Development Team
 *
 * This file is part of MZmine 2.
 *
 * MZmine 2 is free software; you can redistribute it and/or modify it under the terms of the GNU
 * General Public License as published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * MZmine 2 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with MZmine 2; if not,
 * write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301
 * USA
 */

package net.sf.mzmine.modules.peaklistmethods.identification.sirius;

import io.github.msdk.MSDKRuntimeException;
import io.github.msdk.datamodel.MsSpectrum;
import io.github.msdk.datamodel.SimpleMsSpectrum;

import io.github.msdk.util.DataPointSorter;
import io.github.msdk.util.DataPointSorter.SortingDirection;
import io.github.msdk.util.DataPointSorter.SortingProperty;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import net.sf.mzmine.datamodel.DataPoint;
import net.sf.mzmine.datamodel.Feature;
import net.sf.mzmine.datamodel.IsotopePattern;
import net.sf.mzmine.datamodel.MassList;
import net.sf.mzmine.datamodel.PeakListRow;
import net.sf.mzmine.datamodel.RawDataFile;
import net.sf.mzmine.datamodel.Scan;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class SpectrumScanner Allows to process Feature objects (peaks) and return appropriate objects
 * for SiriusIdentificationMethod
 */
public class SpectrumScanner {
  private static final Logger logger = LoggerFactory.getLogger(SpectrumScanner.class);

  private final PeakListRow row;
  private final HashMap<String, int[]> fragmentScans;
  private final String massListName; // Used the value from ExportSirius module.

  private final List<MsSpectrum> ms1list;
  private final List<MsSpectrum> ms2list;

  private boolean includeMs1 = true;

  /**
   * Constructor for SpectrumScanner
   * 
   * @param row
   */
  public SpectrumScanner(@Nonnull PeakListRow row, String massListName)
      throws ScanMassListException {
    this.row = row;
    this.massListName = massListName;
    ms1list = new LinkedList<>();
    ms2list = new LinkedList<>();

    fragmentScans = getFragmentScans(row.getRawDataFiles());
    processRow();
  }

  /**
   * Function taken from SiriusExportTask class, getFragmentScans()
   * 
   * @param rawDataFiles
   * @return
   */
  private HashMap<String, int[]> getFragmentScans(RawDataFile[] rawDataFiles) {
    final HashMap<String, int[]> fragmentScans = new HashMap<>();
    for (RawDataFile r : rawDataFiles) {
      int[] scans = new int[0];
      for (int msLevel : r.getMSLevels()) {
        if (msLevel > 1) {
          int[] concat = r.getScanNumbers(msLevel);
          int offset = scans.length;
          scans = Arrays.copyOf(scans, scans.length + concat.length);
          System.arraycopy(concat, 0, scans, offset, concat.length);
        }
      }
      Arrays.sort(scans);
      fragmentScans.put(r.getName(), scans);
    }
    return fragmentScans;
  }


  /**
   * Method processes a row and constructs CENTROIDED MS1 and MS2 lists 1) Check existence of
   * IsotopePattern 2) Go through scans, receive data points according to Mass List name. 3) Submit
   * points into a new MsSpectrum
   * 
   * @throws ScanMassListException
   */
  private void processRow() throws ScanMassListException {
    // Specify the Isotope Pattern (in form of MS1 spectrum)

    // todo: do not use it, use just ms1 scans.
    IsotopePattern pattern = row.getBestPeak().getIsotopePattern();
    if (pattern != null) {
      MsSpectrum isotopePattern = buildSpectrum(pattern.getDataPoints());
      ms1list.add(isotopePattern);
    }

    /*
     * Process features, retrieve scans and write spectra. Centroided spectra of level 1&2. Code taken from
     * SiriusExportTask -> exportPeakListRow(...)
     */
    for (Feature f : row.getPeaks()) {
      final int[] scanNumbers = f.getScanNumbers().clone();
      Arrays.sort(scanNumbers);
      int[] fs = fragmentScans.get(f.getDataFile().getName());
      int startWith = scanNumbers[0];
      int j = Arrays.binarySearch(fs, startWith);
      if (j < 0)
        j = (-j - 1);
      for (int k = j; k < fs.length; ++k) {
        final Scan scan = f.getDataFile().getScan(fs[k]);
        if (scan.getMSLevel() > 1 && Math.abs(scan.getPrecursorMZ() - f.getMZ()) < 0.1) {
          /* Parse MS1 level scans */
          if (includeMs1) { // todo: think about non-existence, find out best ms1 scan with largest
                            // intensity.
            // find precursor scan
            int prec = Arrays.binarySearch(scanNumbers, fs[k]);
            if (prec < 0)
              prec = -prec - 1;
            prec = Math.max(0, prec - 1);
            for (; prec < scanNumbers.length && scanNumbers[prec] < fs[k]; ++prec) {
              final Scan precursorScan = f.getDataFile().getScan(scanNumbers[prec]);
              if (precursorScan.getMSLevel() == 1) {
                MassList massList = precursorScan.getMassList(massListName);
                if (massList == null) {
                  logger.debug("[{}] mass list does not exist in a scan = {}. Row id = {}",
                      massListName, scan.getScanNumber(), row.getID());
                  throw new ScanMassListException(String.format("[%d] scan does not contain mass list [%s], row ID = %d",
                      scan.getScanNumber(), massListName, row.getID()));
                }
                DataPoint[] points = massList.getDataPoints();
                if (points.length == 0)
                  continue;
                ms1list.add(buildSpectrum(points));
              }
            }
          }

          /* Parse ms2 level scans */
          MassList massList = scan.getMassList(massListName);
          if (massList == null) {
            logger.debug("[{}] mass list does not exist in a scan = {}. Row id = {}", massListName,
                scan.getScanNumber(), row.getID());
            throw new ScanMassListException(String.format("[%d] scan does not contain mass list [%s], row ID = %d",
                scan.getScanNumber(), massListName, row.getID()));
          }
          DataPoint[] points = massList.getDataPoints();
          if (points.length == 0)
            continue;
          ms2list.add(buildSpectrum(points));
        }
      }
    }
  }

  /**
   * Process RawDataFile and return list with one MsSpectrum of level 1.
   * Returns null if ms1list is empty
   * @return MS spectra list
   */
  public @Nullable List<MsSpectrum> getMsList() {
    if (ms1list.size() == 0)
      return null;
    return ms1list;
  }

  /**
   * Process RawDataFile and return list with one MsSpectrum of level 2.
   * Returns null if ms2list is empty
   * @return MSMS spectra list
   */
  public @Nullable List<MsSpectrum> getMsMsList() {
    if (ms2list.size() == 0)
      return null;
    return ms2list;
  }

  /**
   *
   * @return ms2list contains items or not
   */
  public boolean peakContainsMsMs() {
    return ms2list.size() > 0;
  }

  /**
   * Construct MsSpectrum object from DataPoint array
   * 
   * @param points MZ/Intensity pairs
   * @return new MsSpectrum
   */
  private MsSpectrum buildSpectrum(DataPoint[] points) {
    SimpleMsSpectrum spectrum = new SimpleMsSpectrum();
    double mz[] = new double[points.length];
    float intensity[] = new float[points.length];

    for (int i = 0; i < points.length; i++) {
      mz[i] = points[i].getMZ();
      intensity[i] = (float) points[i].getIntensity();
    }

    try {
      spectrum.setDataPoints(mz, intensity, points.length);
      return spectrum;
    } catch (MSDKRuntimeException f) {
      // m/z values must be sorted in ascending order Exception
      logger.debug("Unsorted sequence appeared on row id = {}", row.getID());
      DataPointSorter.sortDataPoints(mz, intensity, points.length, SortingProperty.MZ,
          SortingDirection.ASCENDING);
      spectrum.setDataPoints(mz, intensity, points.length);
      return spectrum;
    }
  }
}
